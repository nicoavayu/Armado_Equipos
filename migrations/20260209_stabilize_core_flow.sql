-- ============================================================================
-- STABILIZATION: Core app flow reconciliation
-- Date: 2026-02-09
-- Purpose:
-- 1) Canonicalize match_join_requests schema
-- 2) Restore robust approval RPC + admin notification trigger
-- 3) Align notification dispatcher with partidos.creado_por
-- 4) Ensure survey completion trigger listens to post_match_surveys
-- ============================================================================

BEGIN;

-- --------------------------------------------------------------------------
-- A) Canonical table: match_join_requests
-- --------------------------------------------------------------------------
DO $$
DECLARE
  has_table boolean;
  has_match_id boolean;
  has_user_id boolean;
  has_partido_id boolean;
  has_usuario_id boolean;
  has_requester_user_id boolean;
  has_status boolean;
  has_estado boolean;
  has_decided_by boolean;
BEGIN
  SELECT to_regclass('public.match_join_requests') IS NOT NULL INTO has_table;

  IF has_table THEN
    CREATE TABLE IF NOT EXISTS public.match_join_requests_reconciled (
      id bigint generated by default as identity primary key,
      match_id bigint not null references public.partidos(id) on delete cascade,
      user_id uuid not null references public.usuarios(id) on delete cascade,
      status text not null default 'pending' check (status in ('pending', 'approved', 'rejected')),
      created_at timestamptz not null default now(),
      decided_at timestamptz,
      decided_by uuid references public.usuarios(id)
    );

    SELECT EXISTS (
      SELECT 1 FROM information_schema.columns
      WHERE table_schema = 'public' AND table_name = 'match_join_requests' AND column_name = 'match_id'
    ) INTO has_match_id;

    SELECT EXISTS (
      SELECT 1 FROM information_schema.columns
      WHERE table_schema = 'public' AND table_name = 'match_join_requests' AND column_name = 'user_id'
    ) INTO has_user_id;

    SELECT EXISTS (
      SELECT 1 FROM information_schema.columns
      WHERE table_schema = 'public' AND table_name = 'match_join_requests' AND column_name = 'partido_id'
    ) INTO has_partido_id;

    SELECT EXISTS (
      SELECT 1 FROM information_schema.columns
      WHERE table_schema = 'public' AND table_name = 'match_join_requests' AND column_name = 'usuario_id'
    ) INTO has_usuario_id;

    SELECT EXISTS (
      SELECT 1 FROM information_schema.columns
      WHERE table_schema = 'public' AND table_name = 'match_join_requests' AND column_name = 'requester_user_id'
    ) INTO has_requester_user_id;

    SELECT EXISTS (
      SELECT 1 FROM information_schema.columns
      WHERE table_schema = 'public' AND table_name = 'match_join_requests' AND column_name = 'status'
    ) INTO has_status;

    SELECT EXISTS (
      SELECT 1 FROM information_schema.columns
      WHERE table_schema = 'public' AND table_name = 'match_join_requests' AND column_name = 'estado'
    ) INTO has_estado;

    SELECT EXISTS (
      SELECT 1 FROM information_schema.columns
      WHERE table_schema = 'public' AND table_name = 'match_join_requests' AND column_name = 'decided_by'
    ) INTO has_decided_by;

    IF has_match_id AND has_user_id THEN
      EXECUTE format($fmt$
        INSERT INTO public.match_join_requests_reconciled (match_id, user_id, status, created_at, decided_at, decided_by)
        SELECT
          match_id,
          user_id,
          %s,
          COALESCE(created_at, now()),
          decided_at,
          %s
        FROM public.match_join_requests
        WHERE match_id IS NOT NULL AND user_id IS NOT NULL
        ON CONFLICT DO NOTHING
      $fmt$,
      CASE WHEN has_status THEN 'COALESCE(status, ''pending'')' ELSE '''pending''' END,
      CASE WHEN has_decided_by THEN 'decided_by' ELSE 'NULL::uuid' END
      );
    ELSIF has_partido_id AND has_usuario_id THEN
      EXECUTE format($fmt$
        INSERT INTO public.match_join_requests_reconciled (match_id, user_id, status, created_at, decided_at, decided_by)
        SELECT
          partido_id,
          usuario_id,
          %s,
          COALESCE(created_at, now()),
          NULL::timestamptz,
          NULL::uuid
        FROM public.match_join_requests
        WHERE partido_id IS NOT NULL AND usuario_id IS NOT NULL
        ON CONFLICT DO NOTHING
      $fmt$,
      CASE WHEN has_estado THEN 'CASE WHEN estado IN (''pending'',''approved'',''rejected'') THEN estado ELSE ''pending'' END' ELSE '''pending''' END
      );
    ELSIF has_match_id AND has_requester_user_id THEN
      EXECUTE format($fmt$
        INSERT INTO public.match_join_requests_reconciled (match_id, user_id, status, created_at, decided_at, decided_by)
        SELECT
          match_id,
          requester_user_id,
          %s,
          COALESCE(created_at, now()),
          decided_at,
          NULL::uuid
        FROM public.match_join_requests
        WHERE match_id IS NOT NULL AND requester_user_id IS NOT NULL
        ON CONFLICT DO NOTHING
      $fmt$,
      CASE WHEN has_status THEN 'COALESCE(status, ''pending'')' ELSE '''pending''' END
      );
    END IF;

    DROP TABLE public.match_join_requests CASCADE;
    ALTER TABLE public.match_join_requests_reconciled RENAME TO match_join_requests;
  ELSE
    CREATE TABLE public.match_join_requests (
      id bigint generated by default as identity primary key,
      match_id bigint not null references public.partidos(id) on delete cascade,
      user_id uuid not null references public.usuarios(id) on delete cascade,
      status text not null default 'pending' check (status in ('pending', 'approved', 'rejected')),
      created_at timestamptz not null default now(),
      decided_at timestamptz,
      decided_by uuid references public.usuarios(id)
    );
  END IF;
END $$;

CREATE INDEX IF NOT EXISTS match_join_requests_match_id_idx ON public.match_join_requests(match_id);
CREATE INDEX IF NOT EXISTS match_join_requests_user_id_idx ON public.match_join_requests(user_id);
CREATE UNIQUE INDEX IF NOT EXISTS match_join_requests_unique_pending
  ON public.match_join_requests(match_id, user_id)
  WHERE status = 'pending';

ALTER TABLE public.match_join_requests ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "user can request join" ON public.match_join_requests;
CREATE POLICY "user can request join"
ON public.match_join_requests
FOR INSERT
TO authenticated
WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "user can read own requests" ON public.match_join_requests;
CREATE POLICY "user can read own requests"
ON public.match_join_requests
FOR SELECT
TO authenticated
USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "admin can read match requests" ON public.match_join_requests;
CREATE POLICY "admin can read match requests"
ON public.match_join_requests
FOR SELECT
TO authenticated
USING (
  EXISTS (
    SELECT 1
    FROM public.partidos p
    WHERE p.id = match_join_requests.match_id
      AND p.creado_por = auth.uid()
  )
);

DROP POLICY IF EXISTS "admin can update match requests" ON public.match_join_requests;
CREATE POLICY "admin can update match requests"
ON public.match_join_requests
FOR UPDATE
TO authenticated
USING (
  EXISTS (
    SELECT 1
    FROM public.partidos p
    WHERE p.id = match_join_requests.match_id
      AND p.creado_por = auth.uid()
  )
)
WITH CHECK (status IN ('approved', 'rejected'));

-- --------------------------------------------------------------------------
-- B) Join request trigger notification (admin inbox)
-- --------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.notify_admin_join_request()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
  v_admin uuid;
  v_requester_name text;
  v_fecha date;
  v_hora text;
BEGIN
  IF NEW.status <> 'pending' THEN
    RETURN NEW;
  END IF;

  SELECT creado_por, fecha, hora
  INTO v_admin, v_fecha, v_hora
  FROM public.partidos
  WHERE id = NEW.match_id;

  IF v_admin IS NULL THEN
    RETURN NEW;
  END IF;

  SELECT COALESCE(u.nombre, p.nombre, 'Un jugador')
  INTO v_requester_name
  FROM public.usuarios u
  LEFT JOIN public.profiles p ON p.id = u.id
  WHERE u.id = NEW.user_id;

  INSERT INTO public.notifications (
    user_id,
    type,
    title,
    message,
    partido_id,
    data,
    read,
    created_at
  ) VALUES (
    v_admin,
    'match_join_request',
    'Nueva solicitud para unirse',
    v_requester_name || ' quiere unirse al partido del ' ||
      COALESCE(to_char(v_fecha, 'DD/MM'), 'fecha pendiente') || ' · ' ||
      substring(COALESCE(v_hora, '00:00') from 1 for 5),
    NEW.match_id,
    jsonb_build_object(
      'match_id', NEW.match_id,
      'matchId', NEW.match_id,
      'requestId', NEW.id,
      'request_user_id', NEW.user_id,
      'link', '/admin/' || NEW.match_id || '?tab=solicitudes'
    ),
    false,
    now()
  )
  ON CONFLICT DO NOTHING;

  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_notify_admin_join_request ON public.match_join_requests;
CREATE TRIGGER trg_notify_admin_join_request
AFTER INSERT ON public.match_join_requests
FOR EACH ROW EXECUTE FUNCTION public.notify_admin_join_request();

-- --------------------------------------------------------------------------
-- C) Approval RPC (atomic + no duplicate player approvals)
-- --------------------------------------------------------------------------
DROP FUNCTION IF EXISTS public.approve_join_request(bigint);
CREATE OR REPLACE FUNCTION public.approve_join_request(p_request_id bigint)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_match_id bigint;
  v_user_id uuid;
  v_status text;
  v_nombre text;
  v_avatar_url text;
  v_exists boolean;
BEGIN
  SELECT match_id, user_id, status
  INTO v_match_id, v_user_id, v_status
  FROM public.match_join_requests
  WHERE id = p_request_id
  FOR UPDATE;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Solicitud no encontrada';
  END IF;

  SELECT EXISTS (
    SELECT 1
    FROM public.jugadores j
    WHERE j.partido_id = v_match_id
      AND j.usuario_id = v_user_id
  ) INTO v_exists;

  IF v_exists THEN
    RAISE EXCEPTION 'El jugador ya está en el partido';
  END IF;

  IF v_status <> 'approved' THEN
    UPDATE public.match_join_requests
    SET status = 'approved',
        decided_at = now(),
        decided_by = auth.uid()
    WHERE id = p_request_id;
  END IF;

  SELECT
    COALESCE(u.nombre, p.nombre, 'Jugador'),
    COALESCE(u.avatar_url, p.avatar_url)
  INTO v_nombre, v_avatar_url
  FROM public.usuarios u
  LEFT JOIN public.profiles p ON p.id = u.id
  WHERE u.id = v_user_id;

  INSERT INTO public.jugadores (
    partido_id,
    usuario_id,
    nombre,
    avatar_url,
    score,
    is_goalkeeper
  ) VALUES (
    v_match_id,
    v_user_id,
    v_nombre,
    v_avatar_url,
    5,
    false
  );

  RETURN jsonb_build_object(
    'success', true,
    'match_id', v_match_id,
    'user_id', v_user_id
  );
END;
$$;

GRANT EXECUTE ON FUNCTION public.approve_join_request(bigint) TO authenticated;

-- --------------------------------------------------------------------------
-- D) Notification dispatcher aligned with partidos.creado_por
-- --------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.enqueue_partido_notification(
  p_partido_id bigint,
  p_type text,
  p_title text DEFAULT NULL,
  p_message text DEFAULT NULL,
  p_payload jsonb DEFAULT '{}'::jsonb
) RETURNS jsonb AS $$
DECLARE
  v_correlation_id uuid := gen_random_uuid();
  v_recipient_id uuid;
  v_recipients uuid[];
  v_count int := 0;
  v_admin_id uuid;
BEGIN
  SELECT creado_por INTO v_admin_id
  FROM public.partidos
  WHERE id = p_partido_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Partido % not found', p_partido_id;
  END IF;

  CASE p_type
    WHEN 'match_cancelled', 'match_deleted', 'match_kicked', 'survey_start', 'survey_results_ready', 'awards_ready' THEN
      SELECT ARRAY_AGG(DISTINCT usuario_id)
      INTO v_recipients
      FROM public.jugadores
      WHERE partido_id = p_partido_id
        AND usuario_id IS NOT NULL;

      IF v_admin_id IS NOT NULL THEN
        v_recipients := array_append(v_recipients, v_admin_id);
      END IF;
    ELSE
      v_recipients := ARRAY[v_admin_id];
  END CASE;

  v_recipients := ARRAY(
    SELECT DISTINCT uid
    FROM unnest(COALESCE(v_recipients, ARRAY[]::uuid[])) AS uid
    WHERE uid IS NOT NULL
  );

  FOREACH v_recipient_id IN ARRAY v_recipients
  LOOP
    INSERT INTO public.notifications (
      user_id,
      partido_id,
      type,
      title,
      message,
      data,
      read
    ) VALUES (
      v_recipient_id,
      p_partido_id,
      p_type,
      COALESCE(p_title, 'Notificación de partido'),
      COALESCE(p_message, 'Tienes una nueva notificación'),
      p_payload,
      false
    )
    ON CONFLICT DO NOTHING;

    IF to_regclass('public.notification_delivery_log') IS NOT NULL THEN
      INSERT INTO public.notification_delivery_log (
        partido_id,
        user_id,
        notification_type,
        payload_json,
        correlation_id,
        channel,
        status
      ) VALUES (
        p_partido_id,
        v_recipient_id,
        p_type,
        p_payload,
        v_correlation_id,
        'in_app',
        'queued'
      ) ON CONFLICT DO NOTHING;
    END IF;

    v_count := v_count + 1;
  END LOOP;

  RETURN jsonb_build_object(
    'success', true,
    'correlation_id', v_correlation_id,
    'recipients_count', v_count,
    'recipients', COALESCE(v_recipients, ARRAY[]::uuid[])
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- --------------------------------------------------------------------------
-- E) Survey completion trigger on post_match_surveys
-- --------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.check_survey_completion_from_post_match_surveys()
RETURNS trigger AS $$
DECLARE
  v_progress record;
  v_response_count int;
BEGIN
  INSERT INTO public.survey_progress (partido_id, enabled_at, first_response_at, response_count, results_notified, created_at, updated_at)
  VALUES (NEW.partido_id, now(), NEW.created_at, 0, false, now(), now())
  ON CONFLICT (partido_id) DO NOTHING;

  SELECT COUNT(DISTINCT s.votante_id)
  INTO v_response_count
  FROM public.post_match_surveys s
  WHERE s.partido_id = NEW.partido_id;

  UPDATE public.survey_progress
  SET response_count = COALESCE(v_response_count, 0),
      first_response_at = COALESCE(first_response_at, NEW.created_at, now()),
      updated_at = now()
  WHERE partido_id = NEW.partido_id
  RETURNING * INTO v_progress;

  IF v_progress.response_count >= 3 AND v_progress.results_notified = false THEN
    UPDATE public.survey_progress
    SET results_notified = true,
        closed_at = now(),
        updated_at = now()
    WHERE partido_id = NEW.partido_id;

    PERFORM public.enqueue_partido_notification(
      NEW.partido_id,
      'survey_results_ready',
      'Resultados de encuesta listos',
      'Los resultados de la encuesta ya están disponibles',
      jsonb_build_object(
        'match_id', NEW.partido_id,
        'response_count', v_progress.response_count,
        'reason', '3_responses'
      )
    );
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS on_survey_response ON public.votos;
DROP TRIGGER IF EXISTS trg_post_match_survey_completion ON public.post_match_surveys;
CREATE TRIGGER trg_post_match_survey_completion
AFTER INSERT ON public.post_match_surveys
FOR EACH ROW
EXECUTE FUNCTION public.check_survey_completion_from_post_match_surveys();

COMMIT;
